var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as sodium from 'libsodium-wrappers';
import BigNumber from 'bignumber.js';
import { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '../../utils/crypto';
import { MatrixClient } from '../../matrix-client/MatrixClient';
import { MatrixClientEventType } from '../../matrix-client/models/MatrixClientEvent';
import { MatrixMessageType } from '../../matrix-client/models/MatrixMessage';
import { StorageKey } from '../..';
import { BEACON_VERSION } from '../../constants';
import { generateGUID } from '../../utils/generate-uuid';
import { getSenderId } from '../../utils/get-sender-id';
import { Logger } from '../../utils/Logger';
import { CommunicationClient } from './CommunicationClient';
const logger = new Logger('P2PCommunicationClient');
const KNOWN_RELAY_SERVERS = [
    'matrix.papers.tech'
    // 'matrix.tez.ie',
    // 'matrix-dev.papers.tech',
    // "matrix.stove-labs.com",
    // "yadayada.cryptonomic-infra.tech"
];
export class P2PCommunicationClient extends CommunicationClient {
    constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {
        super(keyPair);
        this.name = name;
        this.replicationCount = replicationCount;
        this.storage = storage;
        this.iconUrl = iconUrl;
        this.appUrl = appUrl;
        this.clients = [];
        this.activeListeners = new Map();
        logger.log('constructor', 'P2PCommunicationClient created');
        this.KNOWN_RELAY_SERVERS = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;
    }
    getPairingRequestInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                id: yield generateGUID(),
                type: 'p2p-pairing-request',
                name: this.name,
                version: BEACON_VERSION,
                publicKey: yield this.getPublicKey(),
                relayServer: yield this.getRelayServer()
            };
            if (this.iconUrl) {
                info.icon = this.iconUrl;
            }
            if (this.appUrl) {
                info.appUrl = this.appUrl;
            }
            return info;
        });
    }
    getPairingResponseInfo(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                id: request.id,
                type: 'p2p-pairing-response',
                name: this.name,
                version: BEACON_VERSION,
                publicKey: yield this.getPublicKey(),
                relayServer: yield this.getRelayServer()
            };
            if (this.iconUrl) {
                info.icon = this.iconUrl;
            }
            if (this.appUrl) {
                info.appUrl = this.appUrl;
            }
            return info;
        });
    }
    getRelayServer(publicKeyHash, nonce = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = publicKeyHash || (yield getHexHash(this.keyPair.publicKey));
            return this.KNOWN_RELAY_SERVERS.reduce((prevPromise, curr) => __awaiter(this, void 0, void 0, function* () {
                const prev = yield prevPromise;
                const prevRelayServerHash = yield getHexHash(prev + nonce);
                const currRelayServerHash = yield getHexHash(curr + nonce);
                const prevBigInt = yield this.getAbsoluteBigIntDifference(hash, prevRelayServerHash);
                const currBigInt = yield this.getAbsoluteBigIntDifference(hash, currRelayServerHash);
                return prevBigInt.isLessThan(currBigInt) ? prev : curr;
            }), Promise.resolve(this.KNOWN_RELAY_SERVERS[0]));
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('start', 'starting client');
            yield sodium.ready;
            const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));
            const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);
            logger.log('start', `connecting to ${this.replicationCount} servers`);
            for (let i = 0; i < this.replicationCount; i++) {
                // TODO: Parallel
                const client = MatrixClient.create({
                    baseUrl: `https://${yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString())}`,
                    storage: this.storage
                });
                client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {
                    yield client.joinRooms(event.content.roomId);
                }));
                logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString()));
                yield client
                    .start({
                    id: yield this.getPublicKeyHash(),
                    password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,
                    deviceId: toHex(this.keyPair.publicKey)
                })
                    .catch((error) => logger.log(error));
                yield client.joinRooms(...client.invitedRooms).catch((error) => logger.log(error));
                this.clients.push(client);
            }
        });
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);
            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {
                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {
                    let payload;
                    try {
                        payload = Buffer.from(event.content.message.content, 'hex');
                        // content can be non-hex if it's a connection open request
                    }
                    catch (_a) {
                        /* */
                    }
                    if (payload &&
                        payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {
                        try {
                            const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);
                            // logger.log(
                            //   'listenForEncryptedMessage',
                            //   'encrypted message received',
                            //   decryptedMessage,
                            //   await new Serializer().deserialize(decryptedMessage)
                            // )
                            // console.log('calculated sender ID', await getSenderId(senderPublicKey))
                            // TODO: Add check for correct decryption key / sender ID
                            messageCallback(decryptedMessage);
                        }
                        catch (decryptionError) {
                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                        }
                    }
                }
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
            for (const client of this.clients) {
                client.subscribe(MatrixClientEventType.MESSAGE, callbackFunction);
            }
        });
    }
    unsubscribeFromEncryptedMessage(senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const listener = this.activeListeners.get(senderPublicKey);
            if (!listener) {
                return;
            }
            for (const client of this.clients) {
                client.unsubscribe(MatrixClientEventType.MESSAGE, listener);
            }
            this.activeListeners.delete(senderPublicKey);
        });
    }
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const client of this.clients) {
                client.unsubscribe(MatrixClientEventType.MESSAGE);
            }
            this.activeListeners.clear();
        });
    }
    sendMessage(message, peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sharedTx } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);
            for (let i = 0; i < this.replicationCount; i++) {
                const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));
                const recipient = recipientString(recipientHash, yield this.getRelayServer(recipientHash, i.toString()));
                for (const client of this.clients) {
                    const roomId = yield this.getRelevantRoom(client, recipient);
                    const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);
                    // logger.log(
                    //   'sendMessage',
                    //   'sending encrypted message',
                    //   peer.publicKey,
                    //   roomId,
                    //   message,
                    //   await new Serializer().deserialize(message)
                    // )
                    client.sendTextMessage(roomId, encryptedMessage).catch((error) => __awaiter(this, void 0, void 0, function* () {
                        if (error.errcode === 'M_FORBIDDEN') {
                            // Room doesn't exist
                            logger.log(`sendMessage`, `M_FORBIDDEN`, error);
                            yield this.deleteRoomIdFromRooms(roomId);
                            const newRoomId = yield this.getRelevantRoom(client, recipient);
                            client.sendTextMessage(newRoomId, encryptedMessage).catch((error2) => __awaiter(this, void 0, void 0, function* () {
                                logger.log(`sendMessage`, `inner error`, error2);
                            }));
                        }
                        else {
                            logger.log(`sendMessage`, `not forbidden`, error);
                        }
                    }));
                }
            }
        });
    }
    deleteRoomIdFromRooms(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
            const newRoomIds = Object.entries(roomIds)
                .filter((entry) => entry[1] !== roomId)
                .reduce((pv, cv) => (Object.assign(Object.assign({}, pv), { [cv[0]]: cv[1] })), {});
            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const client of this.clients) {
                client.subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {
                    if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {
                        logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));
                        const splits = event.content.message.content.split(':');
                        const payload = Buffer.from(splits[splits.length - 1], 'hex');
                        if (payload.length >=
                            sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {
                            try {
                                const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));
                                messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey) }));
                            }
                            catch (decryptionError) {
                                /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                            }
                        }
                    }
                }));
            }
        });
    }
    sendPairingResponse(pairingRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log(`sendPairingResponse`);
            const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));
            const recipient = recipientString(recipientHash, pairingRequest.relayServer);
            logger.log(`sendPairingResponse`, `currently there are ${this.clients.length} clients open`);
            for (const client of this.clients) {
                const roomId = yield this.getRelevantRoom(client, recipient);
                // TODO: remove v1 backwards-compatibility
                const message = typeof pairingRequest.version === 'undefined'
                    ? yield this.getPublicKey() // v1
                    : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2
                const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);
                client
                    .sendTextMessage(roomId, ['@channel-open', recipient, encryptedMessage].join(':'))
                    .catch((error) => logger.log(error));
            }
        });
    }
    isTextMessage(content) {
        return content.message.type === MatrixMessageType.TEXT;
    }
    isChannelOpenMessage(content) {
        return __awaiter(this, void 0, void 0, function* () {
            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);
        });
    }
    isSender(event, senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);
        });
    }
    getAbsoluteBigIntDifference(firstHash, secondHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const difference = new BigNumber(`0x${firstHash}`).minus(`0x${secondHash}`);
            return difference.absoluteValue();
        });
    }
    getRelevantRoom(client, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
            let roomId = roomIds[recipient];
            if (!roomId) {
                logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);
                const room = yield this.getRelevantJoinedRoom(client, recipient);
                roomId = room.id;
                roomIds[recipient] = room.id;
                yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);
            }
            logger.log(`getRelevantRoom`, `Using room ${roomId}`);
            return roomId;
        });
    }
    getRelevantJoinedRoom(client, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const joinedRooms = client.joinedRooms;
            const relevantRooms = joinedRooms.filter((roomElement) => roomElement.members.some((member) => member === recipient));
            let room;
            if (relevantRooms.length === 0) {
                logger.log(`getRelevantJoinedRoom`, `no relevant rooms found`);
                const roomId = yield client.createTrustedPrivateRoom(recipient);
                room = client.getRoomById(roomId);
            }
            else {
                room = relevantRooms[0];
                logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);
            }
            return room;
        });
    }
}
//# sourceMappingURL=P2PCommunicationClient.js.map